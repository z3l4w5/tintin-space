<!DOCTYPE html>
<html lang="zh" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="1.1 The stack in Jamstack#To understand Jamstack fully, we first need to understand the concept of a web stack. The web stack is a collection of software used for web application development. Some popular web stacks include LAMP (Linux Apache MySQL PHP), Microsoft .NET (IIS, ASP.NET, MS SQL Server), MEAN (MongoDB Express Angular Node.js), and MERN (MongoDB Express React Node.js). Figure 1.1 shows a typical web stack for a non- Jamstack-based website.">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="1.1 The stack in Jamstack" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://hugo-in-action.foofun.cn/zh/docs/part1/chapter1/1/" />

<title>1.1 The stack in Jamstack | Hugo In Action</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
  <link rel="alternate" hreflang="en" href="https://hugo-in-action.foofun.cn/docs/part1/chapter1/1/" title="1.1 The stack in Jamstack">
<link rel="stylesheet" href="/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css" integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/zh.search.min.d0100a87adc7afabb15fd94c3da6218be2cea39f5b6fd789fec337774c9812df.js" integrity="sha256-0BAKh63Hr6uxX9lMPaYhi&#43;LOo59bb9eJ/sM3d0yYEt8=" crossorigin="anonymous"></script>

  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" integrity="sha256-b2&#43;Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC&#43;NdcPIvZhzk=" crossorigin="anonymous"></script>
<link rel="alternate" type="application/rss+xml" href="https://hugo-in-action.foofun.cn/zh/docs/part1/chapter1/1/index.xml" title="Hugo In Action" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Hugo In Action</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>



  



  
    
  


  


<ul class="book-languages">
  <li>
    <input type="checkbox" id="languages" class="toggle" />
    <label for="languages" class="flex justify-between">
      <a role="button" class="flex align-center">
        <img src="/svg/translate.svg" class="book-icon" alt="Languages" />
        简体中文
      </a>
    </label>

    <ul>
      
      <li>
        <a href="https://hugo-in-action.foofun.cn/docs/part1/chapter1/1/">
          English
        </a>
      </li>
      
    </ul>
  </li>
</ul>











  <ul>
<li>
  <a href="/zh/docs/part1/"><strong>第1部分 静态Hugo网站：快速加载，持续构建</strong></a></li>
<li>
  <a href="/zh/docs/part1/chapter1/">1 Jamstack和Hugo</a>
<ul>
<li>
  <a href="/zh/docs/part1/chapter1/1/"class=active>1.1 JamStack的工作栈</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/2/">1.2 Jamstack是如何工作的？</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/3/">1.3 JamstackK中的JAM</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/4/">1.4 为什么要使用Jamstack？</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/5/">1.5 何时不使用Jamstack</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/6/">1.6 选择构建器</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/7/">1.7 为什么选择Hugo？</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/8/">1.8 速度真的很重要吗？</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/9/">1.9 我们能用Hugo构建什么？</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/10/">1.10 无法映射到Hugo的场景</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/11/">1.11 如何在Hugo和这本书中取得成功</a></li>
<li>
  <a href="/zh/docs/part1/chapter1/summary/">总结</a></li>
</ul>
</li>
<li>
  <a href="/zh/docs/part1/chapter2/">2 30分钟上线: 建立你自己的网站</a>
<ul>
<li>
  <a href="/zh/docs/part1/chapter2/1/">2.1 你的第一个Hugo网站</a></li>
<li>
  <a href="/zh/docs/part1/chapter2/2/">2.2 添加主题</a></li>
<li>
  <a href="/zh/docs/part1/chapter2/3/">2.3 添加内容</a></li>
<li>
  <a href="/zh/docs/part1/chapter2/4/">2.4 持续交付</a></li>
<li>
  <a href="/zh/docs/part1/chapter2/5/">2.5 满足性能和可维护性目标</a></li>
<li>
  <a href="/zh/docs/part1/chapter2/summary/">总结</a></li>
</ul>
</li>
<li>
  <a href="/zh/docs/part1/chapter3/">3 使用标记语言实现内容</a>
<ul>
<li>
  <a href="/zh/docs/part1/chapter3/1/">3.1 用Markdown编写内容</a></li>
<li>
  <a href="/zh/docs/part1/chapter3/2/">3.2 Markdown实战</a></li>
<li>
  <a href="/zh/docs/part1/chapter3/3/">3.3 其他标记语言</a></li>
<li>
  <a href="/zh/docs/part1/chapter3/4/">3.4 Metadata</a></li>
<li>
  <a href="/zh/docs/part1/chapter3/5/">3.5 其他元数据语言</a></li>
<li>
  <a href="/zh/docs/part1/chapter3/6/">3.6 Front matter</a></li>
<li>
  <a href="/zh/docs/part1/chapter3/7/">3.7 使用标记和元数据语言的好处</a></li>
<li>
  <a href="/zh/docs/part1/chapter3/summary/">总结</a></li>
</ul>
</li>
<li>
  <a href="/zh/docs/part1/chapter4/">4 Hugo的内容管理</a>
<ul>
<li>
  <a href="/zh/docs/part1/chapter4/1/">4.1 使用Hugo配置进行定制</a></li>
<li>
  <a href="/zh/docs/part1/chapter4/2/">4.2 用sections和menus组织内容</a></li>
<li>
  <a href="/zh/docs/part1/chapter4/3/">4.3 更好地与页面bundles一起使用</a></li>
<li>
  <a href="/zh/docs/part1/chapter4/4/">4.4 不仅仅是标签: Taxonomies</a></li>
<li>
  <a href="/zh/docs/part1/chapter4/5/">4.5 YouTube、Gists和其他通过shortcodes提供的代码片段</a></li>
<li>
  <a href="/zh/docs/part1/chapter4/6/">4.6 使用自定义shortcodes的内容共享</a></li>
<li>
  <a href="/zh/docs/part1/chapter4/summary/">总结</a></li>
</ul>
</li>
<li>
  <a href="/zh/docs/part1/chapter5/">5 使用GO模板语言定制页面和定制内容</a>
<ul>
<li>
  <a href="/zh/docs/part1/chapter5/1/">5.1 分离数据和设计</a></li>
<li>
  <a href="/zh/docs/part1/chapter5/2/">5.2 使用外部数据添加内容</a></li>
<li>
  <a href="/zh/docs/part1/chapter5/3/">5.3 使用结构化数据</a></li>
<li>
  <a href="/zh/docs/part1/chapter5/4/">5.4 使用GO模板语言进行改进</a></li>
<li>
  <a href="/zh/docs/part1/chapter5/summary/">总结</a></li>
</ul>
</li>
<li>
  <a href="/zh/docs/part1/chapter6/">6 结构化网页</a>
<ul>
<li>
  <a href="/zh/docs/part1/chapter6/1/">6.1 使用内容类型、基本模板和块来构建模板结构</a></li>
<li>
  <a href="/zh/docs/part1/chapter6/2/">6.2 用partials重用内容</a></li>
<li>
  <a href="/zh/docs/part1/chapter6/3/">6.3 用Hugo管道处理资产</a></li>
<li>
  <a href="/zh/docs/part1/chapter6/4/">6.4 控制Markdown渲染</a></li>
<li>
  <a href="/zh/docs/part1/chapter6/5/">6.5 将bundled templates用于公共工作</a></li>
<li>
  <a href="/zh/docs/part1/chapter6/summary/">总结</a></li>
</ul>
</li>
<li>
  <a href="/zh/docs/part1/chapter7/">7 创建自己的主题</a>
<ul>
<li>
  <a href="/zh/docs/part1/chapter7/1/">7.1 布局内容的更多方式</a></li>
<li>
  <a href="/zh/docs/part1/chapter7/2/">7.2 通过提供内容和subsection列表来更新索引页面</a></li>
<li>
  <a href="/zh/docs/part1/chapter7/3/">7.3 提供taxonomy页面</a></li>
<li>
  <a href="/zh/docs/part1/chapter7/4/">7.4 创造我们自己的主题</a></li>
<li>
  <a href="/zh/docs/part1/chapter7/5/">7.5 为内容视图提供动力</a></li>
<li>
  <a href="/zh/docs/part1/chapter7/summary/">总结</a></li>
</ul>
</li>
<li>
  <a href="/zh/docs/part1/chapter8/">8 Hugo模块: 所有人的插件</a>
<ul>
<li>
  <a href="/zh/docs/part1/chapter8/1/">8.1 设置Hugo模块</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/2/">8.2 作为Hugo模块的主题</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/3/">8.3 正在导入主题</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/4/">8.4 启用Eclectic以外的主题</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/5/">8.5 获取主题的特定版本</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/6/">8.6 查看依赖关系源代码</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/7/">8.7 在本地修改依赖项</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/8/">8.8 添加嵌套依赖项</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/9/">8.9 作为模板插件的模块</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/10/">8.10 跨主题和网站的共享依赖关系</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/11/">8.11 内容插件</a></li>
<li>
  <a href="/zh/docs/part1/chapter8/summary/">总结</a></li>
</ul>
</li>
</ul>










</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>1.1 The stack in Jamstack</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#11-the-stack-in-jamstack">1.1 The stack in Jamstack</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="11-the-stack-in-jamstack">
  1.1 The stack in Jamstack
  <a class="anchor" href="#11-the-stack-in-jamstack">#</a>
</h1>
<p>To understand Jamstack fully, we first need to understand the concept of a web stack. The web stack is a collection of software used for web application development. Some popular web stacks include LAMP (Linux Apache MySQL PHP), Microsoft .NET (IIS, ASP.NET, MS SQL Server), MEAN (MongoDB Express Angular Node.js), and MERN (MongoDB Express React Node.js). Figure 1.1 shows a typical web stack for a non- Jamstack-based website.</p>
<p>A web page consists of static as well as dynamic assets. Different servers serve these assets in the stack. A web server like Apache or IIS primarily hosts static assets such as images, JavaScript, and CSS in a traditional web stack. These files do not change  across multiple users. A second set of assets is dynamic content, which can be differ- ent. It is based on the supplied request parameters, which include the URL, request headers, cookies, or associated HTTP POST data. An application server with software like PHP, ASP.NET, or Express takes these parameters and creates a response. It might need to do a series of requests to the database server (like MySQL or MongoDB) that holds the website’s content. The application server takes this content and uses the application logic to stitch it into a JSON response (in MEAN/MERN) or, with an HTML template, into HTML content (in LAMP), which it then serves to the web browser. The web page is assembled in the browser by executing the JavaScript and styling the provided content and images with CSS.</p>
<p>This web architecture has been mostly the same since the beginning of the inter- net, but growth and increased traffic have stressed this architecture. Increasing the CPU and RAM in the servers (called vertical scaling) cannot handle the amount of
traffic moving through the modern internet. This load requires us to add multiple machines (called horizontal scaling) to the stack.</p>
<p>
  <img src="Figure1.1.svg" alt="Figure1.1" /></p>
<p>Figure 1.1 A traditional web stack used for development. Non-Jamstack websites have a stack with web servers that provide static assets. Application servers provide dynamic content, generated by using the data stored in the database server and assembled and rendered in the web browser.</p>
<p>Web servers are easy to scale. Because the content does not change, we can replicate it across multiple machines that share the load. CDNs perform the task of copying these assets across nodes geographically closer to the end user and provide internet  scaling  of all network traffic at faster speeds for the end user. Figure 1.2 shows the scaling strat- egies for the web server on the left.</p>
<p>
  <img src="Figure1.2.svg" alt="Figure1.2" /></p>
<p>Figure 1.2 The traditional web stack needs scaling to handle the load on the web. Horizontally scaling the web servers (left) is easy. We can add as many web servers as needed to handle the load. Scaling the application stack (right) is difficult. We cannot have hundreds of database servers (horizontal scaling), and there is a limit to the RAM and CPU capacities (vertical scaling) we can have in these servers. A variety of caching techniques are needed to solve this problem. Jamstack suggests (top) moving as much work as possible from the application servers to the web servers.</p>
<p>The application layers (application and database servers) are a lot harder to scale. If    we keep the requests stateless by managing the user’s state on the client (via JavaScript or cookies), we can scale the application servers horizontally. Because these servers handle the application logic, it is harder to move these to a CDN.</p>
<p>The database layer is the hardest to scale. The CAP theorem tells us that scaling a regular database is not possible at the internet scale. (We cannot horizontally scale to thousands of MySQL servers.) The theorem  states that in a distributed database, we  can simultaneously have, at maximum, two of the three CAP properties:</p>
<ul>
<li>Consistency—Every read receives the most recent write or an error.</li>
<li>Availability —Every request gets a (non-error) response.</li>
<li>Partition tolerance—The system continues to operate despite an arbitrary num- ber of messages being dropped (or delayed) by the network between nodes).</li>
</ul>
<p>Workarounds such as eventual consistency are present in the application stack, where the database is not consistent but becomes so after some time. These workarounds lead to difficulties in the application logic and force constraints on some of the things we can achieve with server technology.</p>
<p>Despite the problems, the traditional web stack has survived the internet scale. One of the biggest reasons why the stack has worked despite database scalability prob- lems is the type of load. Database changes are an order of magnitude less, in most cases, than the retrieval of that data. We can relieve the database retrieval load by add- ing layers of caching. Read replicas for the database and RAM-based caching on the application servers are both solutions for this. We have even found that many web pages do not change across multiple requests. Many websites can add CDNs over the application layer to ease that load. Figure 1.2 on the right shows this solution.</p>
<p>Looking at figure 1.2 closely, the application layer is similar to the web server layer. It is a lot harder to manage the caching layers in the application servers built for dynamic calculations. Jamstack upends the traditional web stack by moving most of   the logic out of the application into the web server layer.</p>
<blockquote class="book-hint warning">
  <strong>NOTE</strong>
Jamstack is not a web stack in the traditional sense. It does not prescribe any specific technology for use in developing websites. It provides an approach to web development where most of the website is prebuilt and client-side script- ing adds dynamicity. This changes the nature and arrangement of software in the traditional stack.
</blockquote>

<p>Being explicit about trying to cache everything makes cache management a lot sim- pler. We can precompute and cache a lot of the work that needs dynamic computa- tion. This precomputation (also called compilation and prerendering in Jamstack) provides an added benefit of enhanced performance because no calculation is needed in the server when the user requests data.</p>
<p>Jamstack does not prohibit server-side or client-side processing. It advises using these only when required. Precomputation during deployment is more efficient, and web servers have fewer security issues and maintenance needs than application servers.</p>
<p>Figure 1.3 provides a comparison of the Jamstack with the traditional web stack at run time for the first issued request that fetches the HTML page. For the initial HTML in the classic approach, the query needs to go through to the service’s origin server across the internet. The load balancer then selects an application server. The
application server may send multiple requests to the database to get the data it needs. It assembles the response based on the application logic and the HTML template that is a part of the application code to create the final HTML passed on to the client for rendering. With Jamstack, the compilation step has already performed database processing and application logic-based stitching. This HTML generation does not happen for every request. Therefore the request does not need to go across the internet to the origin server. A CDN location geographically close to the client serves the content.</p>
<p>
  <img src="Figure1.3.svg" alt="Figure1.3" /></p>
<p>Figure 1.3 A comparison of the first request’s run-time impact in a traditional web stack with the Jamstack architecture. In the conventional approach, when we request the initial HTML page, it goes through the load balancer to the application server. The application server does multiple database calls to get the data and then creates the HTML page based on the template. In the Jamstack approach, the HTML is precomputed and comes from a CDN.</p>
<p>Note that figure 1.3 shows only the initial request for data. Normally, there are additional calls for images, JavaScript, and CSS files. These requests might ask for
more data from the origin server or from third-party services.</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">


  <div><a class="flex align-center" href="https://gitee.com/zhang3/hugo-in-action.git/commit/7852976f45fd2908d4939a9ac97b3c321fbf2072" title='最后修改者 zhang3 | 2022-September-15' target="_blank" rel="noopener">
      <img src="/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>2022-September-15</span>
    </a>
  </div>




</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#11-the-stack-in-jamstack">1.1 The stack in Jamstack</a></li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












